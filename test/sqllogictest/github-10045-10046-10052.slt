# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

# Regression tests from a representation types PR that was merged too early.

mode cockroach

# 10052

statement ok
CREATE  TABLE  database1_t0(c0 INT , c1 VARCHAR , c2 VARCHAR(500), c3 INT );

statement ok
CREATE  TABLE  database1_t1(c0 INT , c1 VARCHAR(500) );

statement ok
CREATE VIEW database1_v0(c0) AS SELECT CAST(database1_t1.c0 AS BOOLEAN) FROM database1_t1 OFFSET 1275367570;

statement ok
SELECT database1_t0.c0, database1_t0.c1, database1_t0.c2, database1_t0.c3, database1_t1.c0, database1_t1.c1, database1_v0.c0 FROM database1_v0, database1_t0 LEFT  JOIN database1_t1 ON ((database1_t0.c2)<>(database1_t0.c1)) WHERE ((database1_t0.c1)IS NOT DISTINCT FROM('d'));


# 10045

statement ok
SELECT pg_catalog.pg_get_viewdef(NULL) AS c2
FROM (SELECT DISTINCT mz_internal.mz_normalize_schema_name(NULL) AS c0,
                      mz_internal.aclitem_grantee(pg_catalog.makeaclitem(0,
                                                                         1,
                                                                         CAST(0 AS text),
                                                                         FALSE)) AS c1,
                      CAST(0 AS uint2) AS c2,
                      30 AS c3,
                      53 AS c4,
                      47 AS c5
      WHERE CAST(0 AS bpchar) ~ pg_catalog."user"()) AS subq_2;

# 10045/10046

statement ok
EXPLAIN RAW PLAN WITH (TYPES, NO FAST PATH) AS TEXT FOR SELECT
  (((null::int8) / (mz_catalog.datediff(
          CAST(pg_catalog.right(
            CAST(1::text as text),
            CAST(80 as int4)) as text),
          CAST(TIMESTAMP(3) '2023-01-01 01:23:45' as timestamp),
          CAST(pg_catalog.timezone(
            CAST(INTERVAL '1' MINUTE as interval),
            CAST(TIMESTAMPTZ '2023-01-01 01:23:45+06' as timestamptz)) as timestamp)))) % (case when (cast(coalesce('{"1":2,"3":4}'::jsonb,
            '{"1":2,"3":4}'::jsonb) as jsonb)) ? (pg_catalog.reverse(
            CAST(null::text as text))) then pg_catalog.pg_relation_size(
          CAST(1::regclass as regclass),
          CAST(cast(coalesce(cast(0 as text),
            cast(0 as text)) as text) as text)) else pg_catalog.pg_relation_size(
          CAST(1::regclass as regclass),
          CAST(cast(coalesce(cast(0 as text),
            cast(0 as text)) as text) as text)) end
        )) / (pg_catalog.pg_relation_size(
      CAST(cast(0 as regclass) as regclass))) as c0,
  pg_catalog.floor(
    CAST((case when false then case when (1::text) >= (1::text) then 1::numeric else 1::numeric end
           else case when (1::text) >= (1::text) then 1::numeric else 1::numeric end
           end
        ) / (case when 17 is not NULL then case when 36 is NULL then (cast(0 as numeric)) % (cast(0 as numeric)) else (cast(0 as numeric)) % (cast(0 as numeric)) end
           else case when 36 is NULL then (cast(0 as numeric)) % (cast(0 as numeric)) else (cast(0 as numeric)) % (cast(0 as numeric)) end
           end
        ) as numeric)) as c1,
  (pg_catalog.jsonb_build_array()) #> (pg_catalog.parse_ident(
      CAST(pg_catalog.pg_get_viewdef(
        CAST(pg_catalog.current_user() as text)) as text))) as c2,
  (pg_catalog.mod(
      CAST(32767::int2 as int2),
      CAST((pg_catalog.mod(
          CAST(case when 6 is not NULL then null::int2 else null::int2 end
             as int2),
          CAST(32767::int2 as int2))) # (-32768::int2) as int2))) % ((~ 32767::int2) / (((pg_catalog.mod(
            CAST(null::int2 as int2),
            CAST(-32768::int2 as int2))) # ((-32768::int2) & (32767::int2))) / (case when ('{"1":2,"3":4}'::jsonb) < ('{"1":2,"3":4}'::jsonb) then null::int2 else null::int2 end
          ))) as c3
from
  (select distinct
        mz_internal.mz_normalize_schema_name(
          CAST(('{"1":2,"3":4}'::jsonb) ->> (null::int8) as text)) as c0,
        mz_internal.aclitem_grantee(
          CAST(pg_catalog.makeaclitem(
            CAST(cast(0 as oid) as oid),
            CAST(1::oid as oid),
            CAST(cast(0 as text) as text),
            CAST(false as bool)) as aclitem)) as c1,
        (0::uint2) * (~ 0::uint2) as c2,
        30 as c3,
        53 as c4,
        47 as c5
      from
        (select
              44 as c0,
              84 as c1
            from
              (select
                    41 as c0
                  from
                    "mz_introspection"."mz_compute_frontiers_per_worker" as ref_0
                  where (10::oid) < (cast(0 as oid))) as subq_0
            where (null::mz_timestamp) > (cast(0 as mz_timestamp))) as subq_1
      where (case when (cast(0 as mz_timestamp)) = (1::mz_timestamp) then cast(0 as bpchar) else cast(0 as bpchar) end
          ) ~ (cast(coalesce(pg_catalog.user(),
          ('"foo"'::jsonb) ->> (null::int8)) as text))) as subq_2
where (cast(coalesce(null::name,
    cast(nullif(cast(0 as name),
      null::name) as name)) as name)) <> (1::name);
